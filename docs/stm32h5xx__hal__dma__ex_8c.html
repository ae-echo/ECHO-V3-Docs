<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ECHO V3: Firmware/Drivers/STM32H5xx_HAL_Driver/Src/stm32h5xx_hal_dma_ex.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ECHO V3<span id="projectnumber">&#160;1.00.00</span>
   </div>
   <div id="projectbrief">ECHO Firmware</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('stm32h5xx__hal__dma__ex_8c.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">stm32h5xx_hal_dma_ex.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>DMA Extension HAL module driver This file provides firmware functions to manage the following functionalities of the DMA extension peripheral:  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="stm32h5xx__hal_8h_source.html">stm32h5xx_hal.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for stm32h5xx_hal_dma_ex.c:</div>
<div class="dyncontent">
<div class="center"><img src="stm32h5xx__hal__dma__ex_8c__incl.png" border="0" usemap="#a_firmware_2_drivers_2_s_t_m32_h5xx___h_a_l___driver_2_src_2stm32h5xx__hal__dma__ex_8c" alt=""/></div>
<map name="a_firmware_2_drivers_2_s_t_m32_h5xx___h_a_l___driver_2_src_2stm32h5xx__hal__dma__ex_8c" id="a_firmware_2_drivers_2_s_t_m32_h5xx___h_a_l___driver_2_src_2stm32h5xx__hal__dma__ex_8c">
<area shape="rect" title="DMA Extension HAL module driver This file provides firmware functions to manage the following functio..." alt="" coords="1583,5,1781,64"/>
<area shape="rect" href="stm32h5xx__hal_8h.html" title="This file contains all the functions prototypes for the HAL module driver." alt="" coords="1622,112,1742,139"/>
<area shape="poly" title=" " alt="" coords="1685,64,1685,96,1680,96,1680,64"/>
<area shape="rect" href="stm32h5xx__hal__conf_8h.html" title="HAL configuration file." alt="" coords="1606,187,1758,213"/>
<area shape="poly" title=" " alt="" coords="1685,139,1685,171,1680,171,1680,139"/>
<area shape="rect" href="stm32h5xx__hal__rcc_8h.html" title="Header file of RCC HAL module." alt="" coords="308,261,454,288"/>
<area shape="poly" title=" " alt="" coords="1606,207,1155,229,542,264,469,269,469,264,542,259,1155,224,1605,202"/>
<area shape="rect" href="stm32h5xx__hal__gpio_8h.html" title="Header file of GPIO HAL module." alt="" coords="1664,261,1815,288"/>
<area shape="poly" title=" " alt="" coords="1694,212,1722,247,1718,251,1690,216"/>
<area shape="rect" href="stm32h5xx__hal__icache_8h.html" title="Header file of ICACHE HAL module." alt="" coords="1840,261,2005,288"/>
<area shape="poly" title=" " alt="" coords="1725,211,1866,254,1865,259,1723,216"/>
<area shape="rect" href="stm32h5xx__hal__dcache_8h.html" title="Header file of DCACHE HAL module." alt="" coords="2030,261,2199,288"/>
<area shape="poly" title=" " alt="" coords="1758,211,2024,256,2023,261,1757,217"/>
<area shape="rect" href="stm32h5xx__hal__dma_8h.html" title="Header file of DMA HAL module." alt="" coords="2223,261,2376,288"/>
<area shape="poly" title=" " alt="" coords="1759,207,2208,258,2207,264,1759,212"/>
<area shape="rect" href="stm32h5xx__hal__cortex_8h.html" title="Header file of CORTEX HAL module." alt="" coords="2399,261,2562,288"/>
<area shape="poly" title=" " alt="" coords="1759,204,2031,225,2384,258,2384,264,2030,231,1759,209"/>
<area shape="rect" href="stm32h5xx__hal__adc_8h.html" title="Header file of ADC HAL module." alt="" coords="2587,261,2735,288"/>
<area shape="poly" title=" " alt="" coords="1759,202,2106,221,2335,237,2571,258,2571,264,2335,243,2106,226,1759,207"/>
<area shape="rect" href="stm32h5xx__hal__dac_8h.html" title="Header file of DAC HAL module." alt="" coords="5,336,154,363"/>
<area shape="poly" title=" " alt="" coords="1605,204,1330,206,951,214,755,221,572,232,414,246,296,264,247,277,198,295,118,331,116,326,196,290,245,272,295,259,414,240,571,226,754,216,951,208,1330,200,1605,199"/>
<area shape="rect" href="stm32h5xx__hal__flash_8h.html" title="Header file of FLASH HAL module." alt="" coords="554,261,709,288"/>
<area shape="poly" title=" " alt="" coords="1606,209,788,264,725,269,724,263,787,259,1605,204"/>
<area shape="rect" href="stm32h5xx__hal__sdram_8h.html" title="Header file of SDRAM HAL module." alt="" coords="2810,261,2973,288"/>
<area shape="poly" title=" " alt="" coords="1759,201,2198,220,2492,236,2792,259,2795,259,2795,264,2791,264,2492,242,2198,225,1759,206"/>
<area shape="rect" href="stm32h5xx__hal__i2c_8h.html" title="Header file of I2C HAL module." alt="" coords="799,261,944,288"/>
<area shape="poly" title=" " alt="" coords="1606,211,959,268,959,263,1605,205"/>
<area shape="rect" href="stm32h5xx__hal__i3c_8h.html" title="Header file of I3C HAL module." alt="" coords="2757,336,2901,363"/>
<area shape="poly" title=" " alt="" coords="1759,200,1997,205,2306,215,2588,232,2689,244,2749,259,2769,271,2788,287,2815,321,2811,325,2784,291,2766,276,2746,264,2688,250,2588,238,2306,220,1997,210,1759,205"/>
<area shape="rect" href="stm32h5xx__hal__pwr_8h.html" title="Header file of PWR HAL module." alt="" coords="1043,261,1191,288"/>
<area shape="poly" title=" " alt="" coords="1606,214,1207,265,1206,259,1605,208"/>
<area shape="rect" href="stm32h5xx__hal__tim_8h.html" title="Header file of TIM HAL module." alt="" coords="1270,261,1415,288"/>
<area shape="poly" title=" " alt="" coords="1623,217,1417,260,1416,255,1622,211"/>
<area shape="rect" href="stm32h5xx__hal__uart_8h.html" title="Header file of UART HAL module." alt="" coords="1440,261,1589,288"/>
<area shape="poly" title=" " alt="" coords="1654,216,1559,257,1556,252,1652,211"/>
<area shape="rect" href="stm32h5xx__hal__exti_8h.html" title="Header file of EXTI HAL module." alt="" coords="1640,336,1788,363"/>
<area shape="poly" title=" " alt="" coords="1674,215,1655,249,1651,268,1654,287,1667,307,1684,324,1680,328,1663,311,1649,289,1646,268,1650,247,1670,213"/>
<area shape="rect" href="stm32h5xx__hal__def_8h.html" title="This file contains HAL common defines, enumeration, macros and structures definitions." alt="" coords="1586,411,1731,437"/>
<area shape="poly" title=" " alt="" coords="383,288,387,326,395,345,408,360,424,367,458,373,568,384,901,401,1277,412,1570,419,1570,424,1277,418,901,406,568,389,457,378,423,372,405,365,390,348,382,327,378,289"/>
<area shape="rect" href="stm32h5xx__hal__rcc__ex_8h.html" title="Header file of RCC HAL Extended module." alt="" coords="178,336,344,363"/>
<area shape="poly" title=" " alt="" coords="361,291,296,330,293,325,359,286"/>
<area shape="rect" href="stm32h5xx_8h.html" title="CMSIS STM32H5xx Device Peripheral Access Layer Header File." alt="" coords="2315,485,2412,512"/>
<area shape="poly" title=" " alt="" coords="1731,430,2300,488,2300,493,1731,435"/>
<area shape="rect" title=" " alt="" coords="1736,560,1797,587"/>
<area shape="poly" title=" " alt="" coords="1641,440,1622,455,1606,473,1597,492,1598,501,1602,510,1626,534,1656,551,1689,561,1721,567,1720,572,1688,566,1654,556,1623,539,1597,514,1592,503,1592,491,1601,470,1619,451,1637,436"/>
<area shape="rect" href="stm32__hal__legacy_8h.html" title="This file contains aliases definition for the STM32Cube HAL constants macros and functions maintained..." alt="" coords="1611,485,1793,512"/>
<area shape="poly" title=" " alt="" coords="1668,436,1689,471,1684,473,1664,439"/>
<area shape="rect" title=" " alt="" coords="1817,485,1886,512"/>
<area shape="poly" title=" " alt="" coords="1693,435,1804,477,1803,482,1691,440"/>
<area shape="poly" title=" " alt="" coords="2315,508,1813,569,1812,564,2315,503"/>
<area shape="poly" title=" " alt="" coords="345,358,362,360,713,384,1057,401,1570,418,1570,423,1057,406,712,389,362,365,344,364"/>
<area shape="poly" title=" " alt="" coords="1761,286,1780,301,1798,320,1808,342,1808,353,1803,364,1777,390,1745,407,1742,403,1774,386,1799,361,1803,352,1803,343,1794,323,1777,305,1758,291"/>
<area shape="rect" href="stm32h5xx__hal__gpio__ex_8h.html" title="Header file of GPIO HAL Extended module." alt="" coords="1864,336,2036,363"/>
<area shape="poly" title=" " alt="" coords="1777,286,1900,328,1898,333,1775,291"/>
<area shape="poly" title=" " alt="" coords="1900,366,1725,409,1723,404,1898,361"/>
<area shape="poly" title=" " alt="" coords="1971,286,2007,299,2039,316,2051,327,2058,338,2058,351,2051,364,2030,380,2001,393,1922,411,1832,420,1746,425,1746,419,1831,415,1921,405,1999,388,2028,376,2047,361,2053,350,2053,340,2047,330,2036,321,2005,304,1969,291"/>
<area shape="poly" title=" " alt="" coords="2114,289,2102,327,2090,348,2073,365,2048,378,2015,389,1930,405,1835,416,1747,422,1746,417,1835,411,1929,400,2014,384,2046,373,2070,361,2086,345,2097,325,2109,288"/>
<area shape="poly" title=" " alt="" coords="2278,291,2201,328,2152,348,2102,365,2008,387,1913,403,1747,421,1746,415,1912,398,2007,382,2100,360,2150,343,2199,323,2275,286"/>
<area shape="rect" href="stm32h5xx__hal__dma__ex_8h.html" title="Header file of DMA HAL extension module." alt="" coords="2213,336,2386,363"/>
<area shape="poly" title=" " alt="" coords="2302,289,2302,320,2297,320,2297,289"/>
<area shape="poly" title=" " alt="" coords="2213,363,2194,365,1747,415,1746,410,2194,360,2212,358"/>
<area shape="poly" title=" " alt="" coords="2476,290,2446,328,2425,349,2399,365,2345,383,2273,398,2187,408,2094,416,1904,424,1746,426,1746,421,1904,419,2093,411,2187,403,2272,392,2344,378,2397,360,2421,345,2442,325,2471,287"/>
<area shape="poly" title=" " alt="" coords="2665,288,2664,326,2658,347,2645,365,2626,375,2596,385,2508,399,2391,410,2256,418,1974,425,1747,426,1747,421,1974,420,2256,412,2391,405,2507,394,2595,379,2624,370,2642,361,2653,345,2659,325,2660,288"/>
<area shape="rect" href="stm32h5xx__ll__adc_8h.html" title="Header file of ADC LL module." alt="" coords="2382,411,2519,437"/>
<area shape="poly" title=" " alt="" coords="2673,287,2693,323,2697,344,2690,364,2665,382,2627,396,2535,415,2534,410,2626,391,2663,377,2685,361,2692,344,2688,325,2669,290"/>
<area shape="rect" href="stm32h5xx__hal__adc__ex_8h.html" title="Header file of ADC HAL extended module." alt="" coords="2462,336,2631,363"/>
<area shape="poly" title=" " alt="" coords="2642,291,2581,330,2578,325,2639,286"/>
<area shape="poly" title=" " alt="" coords="2437,440,2392,477,2388,473,2433,436"/>
<area shape="poly" title=" " alt="" coords="2461,363,2442,365,2054,398,1747,420,1746,414,2054,393,2442,360,2461,358"/>
<area shape="poly" title=" " alt="" coords="154,359,166,360,577,389,981,407,1328,416,1570,419,1570,425,1328,421,980,412,577,394,166,365,154,364"/>
<area shape="poly" title=" " alt="" coords="634,288,638,325,646,345,659,361,677,370,707,379,797,393,916,404,1053,411,1340,419,1570,420,1570,426,1339,424,1053,417,915,409,796,399,706,384,675,375,655,365,641,348,633,327,628,289"/>
<area shape="rect" href="stm32h5xx__hal__flash__ex_8h.html" title="Header file of FLASH HAL module." alt="" coords="418,336,594,363"/>
<area shape="poly" title=" " alt="" coords="611,291,542,330,540,326,608,286"/>
<area shape="poly" title=" " alt="" coords="595,358,613,360,887,380,1157,397,1570,417,1570,422,1157,402,886,386,613,365,594,364"/>
<area shape="poly" title=" " alt="" coords="874,288,879,325,887,345,900,361,935,374,999,386,1183,403,1393,414,1571,419,1570,424,1393,419,1183,409,998,391,933,379,897,365,882,347,874,327,869,289"/>
<area shape="rect" href="stm32h5xx__hal__i2c__ex_8h.html" title="Header file of I2C HAL Extended module." alt="" coords="669,336,834,363"/>
<area shape="poly" title=" " alt="" coords="852,291,787,330,784,325,849,286"/>
<area shape="poly" title=" " alt="" coords="835,358,853,360,1254,393,1570,415,1570,420,1253,399,853,365,834,363"/>
<area shape="poly" title=" " alt="" coords="2756,360,2688,365,2153,399,1746,421,1746,416,2153,394,2687,360,2756,355"/>
<area shape="rect" href="stm32h5xx__ll__i3c_8h.html" title="Header file of I3C LL module." alt="" coords="2718,411,2852,437"/>
<area shape="poly" title=" " alt="" coords="2823,365,2803,399,2798,396,2819,362"/>
<area shape="poly" title=" " alt="" coords="2718,439,2427,489,2427,484,2717,434"/>
<area shape="poly" title=" " alt="" coords="1119,288,1124,325,1131,345,1144,361,1174,378,1218,392,1271,403,1331,410,1457,419,1570,421,1570,426,1457,424,1330,416,1270,408,1216,397,1172,383,1140,365,1127,347,1119,326,1114,289"/>
<area shape="rect" href="stm32h5xx__hal__pwr__ex_8h.html" title="Header file of PWR HAL Extended module." alt="" coords="910,336,1079,363"/>
<area shape="poly" title=" " alt="" coords="1097,291,1030,330,1028,325,1094,286"/>
<area shape="poly" title=" " alt="" coords="1080,358,1098,360,1571,411,1570,416,1098,365,1079,363"/>
<area shape="poly" title=" " alt="" coords="1347,287,1358,324,1369,344,1384,361,1415,376,1461,390,1571,410,1570,415,1460,395,1413,381,1381,365,1365,347,1353,326,1342,289"/>
<area shape="rect" href="stm32h5xx__hal__tim__ex_8h.html" title="Header file of TIM HAL Extended module." alt="" coords="1154,336,1320,363"/>
<area shape="poly" title=" " alt="" coords="1325,291,1269,329,1266,325,1322,286"/>
<area shape="poly" title=" " alt="" coords="1311,361,1571,405,1570,410,1310,366"/>
<area shape="poly" title=" " alt="" coords="1529,286,1579,334,1639,397,1635,401,1575,338,1525,290"/>
<area shape="rect" href="stm32h5xx__hal__uart__ex_8h.html" title="Header file of UART HAL Extended module." alt="" coords="1394,336,1565,363"/>
<area shape="poly" title=" " alt="" coords="1511,290,1494,323,1490,321,1506,287"/>
<area shape="poly" title=" " alt="" coords="1512,361,1614,402,1612,407,1510,366"/>
<area shape="poly" title=" " alt="" coords="1707,365,1679,400,1675,397,1702,362"/>
</map>
</div>
</div>
<p><a href="stm32h5xx__hal__dma__ex_8c_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DMA Extension HAL module driver This file provides firmware functions to manage the following functionalities of the DMA extension peripheral: </p>
<dl class="section author"><dt>Author</dt><dd>MCD Application Team<ul>
<li>Linked-List Initialization and De-Initialization Functions</li>
<li>Linked-List I/O Operation Functions</li>
<li>Linked-List Management Functions</li>
<li>Data Handling, Repeated Block and Trigger Configuration Functions</li>
<li>Suspend and Resume Operation Functions</li>
<li>FIFO Status Function</li>
</ul>
</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>Copyright (c) 2023 STMicroelectronics. All rights reserved.</p>
<p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS.</p>
<pre class="fragment">======================================================================================================================
                               ##### How to use this driver #####
======================================================================================================================
  [..]
    Alternatively to the normal programming mode, a DMA channel can be programmed by a list of transfers, known as
    linked-list (list of Node items). Each node is defined by its data structure.
    Each node specifies a standalone DMA channel.
    When enabled, the DMA channel fetch the first linked-list node from SRAM (known as head node). When executed, the
    next linked list node will be fetched and executed. This operation is repeated until the end of the whole
    linked-list queue. Optionally, the linked-list can be linear where the last linked-list queue node is not linked
    to another queue node or circular where the last linked-list node is linked to any linked-list queue node.

        (+) Linear linked-list:
            The DMA channel fetch and execute all DMA linked-list queue from first node (head node) to last node
            (tail node) ones. When the last node is completed, the DMA channel remains in idle state and another
            transfer can be lunched.

        (+) Circular linked-list:
            The DMA channel fetch and execute all DMA linked-list queue from first node (head node) to last node (tail
            node). When last node is executed, the DMA channel fetches the first circular node another time and repeat
            the same sequence in an infinite loop (Circular transfer). To stop the DMA channel, an abort operation is
            required. This linked-list mode replaces the legacy circular transfers.

  [..]
    In order to reduce linked-list queue executing time and power consumption, the DMA channel supports executing the
    dynamic linked-list format. In fact, the DMA supports the execution of 2 types of linked-list formats : static and
    dynamic.

        (+) Static linked-list:
            The static linked-list format refers to the full linked-list node where all DMA channel parameters are
            fetched and executed independently of the redundancy of information.

        (+) Dynamic linked-list:
            The dynamic linked-list format refer to the customized linked-list node where only DMA channel necessary
            parameters are fetched and executed (Example: data size = 20 on previous node, and data size = 20 on the
            current node =&gt; No need to update it).

    For linked-list transfers, the DMA channel can execute the linked-list queue node by node. This feature is named
    link step mode. When activated, enabling the DMA channel first time allows to fetch the head node from memory
    then it stops. Then, another DMA channel enable is needed to execute the node. After that, keeping enabling the
    DMA channel is needed to execute each node until the end of linked-list queue. When the linked-list queue is
    circular, enabling the DMA channel in an infinite loop is required to keep the DMA channel running. This feature
    is useful for debug purpose or asynchronously executing queue nodes.

  [..]
    Each DMA channel transfer (normal or linked-list), is highly configurable according to DMA channel instance
    integrated in devices. These configuration can be :

        (+) Repeated block configuration :
            If the feature is supported, the DMA channel can performs a repeated block transfers. Named also 2
            dimension addressing transfers, this feature can transfer n iteration of programmed block transfer (Block
            transfer is the legacy data size). Additional to the repeat count of a block, DMA channel addresses can
            jump after at burst and block level. The jump length is a programmable parameter defined by DMA user.
             (++) Jump at burst level :
                  The DMA channel keep an empty area, between each 2 consecutive bursts transmitted.
             (++) Jump at block level :
                  The DMA channel keep an empty area, between each 2 consecutive blocks transmitted.

        (+) Trigger :
            The DMA channel transfers can be conditioned by hardware signals edges (rising or falling) named hardware
            triggers. Trigger condition can be applied at :
             (++) Single/Burst level :
                  Each single/burst data transmission is conditioned by a signal trigger hit.
             (++) Block level :
                  Each block data transmission is conditioned by a signal trigger hit.
             (++) Repeated block level :
                  Each repeated block data transmission is conditioned by a signal trigger hit.
             (++) Node level :
                  Each node execution is conditioned by a signal trigger hit.
            The DMA channel can report a trigger overrun when detects more than 2 trigger signal edges before
            executing the current transfer.

        (+) Data handling :
            The data handling feature is a FIFO capability that can be :
              (++) Padding pattern :
                   Padding selected pattern (zero padding or sign extension) when the source data width is smaller
                   than the destination data width at single level.
              (++) Truncation :
                   Truncate section from the source data single when the source data width is bigger than the
                   destination data width.
              (++) Pack/Unpack :
                   Pack a set of data when source data width is smaller than the destination data width.
                   Unpack a set of data when source data width is bigger than the destination data width.
              (++) Exchange :
                   Exchange data at byte and half-word on the destination and at byte level on the source.

  [..]
    Each DMA channel transfer (normal or linked-list) when it is active, can be suspended and resumed at run time
    application. When trying to suspend an ongoing transfer, the DMA channel isn't suspended instantly but complete
    the current ongoing single/burst then it stops.
    When the DMA channel is suspended, the current transfer can be resumed instantly.

  [..]
    The DMA channel that supports FIFO, can report in real time the number of beats remains on destination (Output)
    FIFO level.

  *** Linked-List Initialization and De-Initialization operation ***
  ==================================================================
  [..]
    Differently from normal transfers, DMA channel initialization and de-initialization need less parameters as the
    remaining transfer parameters are defined by linked-list nodes.

        (+) Use HAL_DMAEx_List_Init() to initialize a DMA channel in linked-list mode according to programmed fields.
            When called, the DMA channel will be ready to execute linked-list queues.

        (+) Use HAL_DMAEx_List_DeInit() to de-initialize a DMA channel in linked-list mode.
            When called, the DMA channel will be in reset. It is mandatory to reinitialize it for next transfer.

  *** Linked-List I/O Operation ***
  =================================
  [..]
        (+) Use HAL_DMAEx_List_Start() to start a DMA transfer in linked-list mode after the configuration of
            linked-list queue base address and offset in polling mode (Blocking mode).

        (+) Use HAL_DMAEx_List_Start_IT() to start a DMA transfer in linked-list mode after the configuration of
            linked-list queue base address and offset in interrupt mode (Non-blocking mode).

  *** Linked-List Management ***
  ==============================
  [..]
    The linked-list management is a software processing independently of DMA channel hardware. It allows to reset,
    build, create, insert, remove, replace, circularize, convert both nodes and queue in order to perform DMA
    channel transfers in linked-list mode.
    Linked-list APIs and types are adapted to reduce memory footprint.

  *** Linked-list nodes building ***
  [..]
    At node level, the operations that can be done are building a new linked-list node or get a linked-list node
    information from a built node. The linked-list nodes have two forms according to 2 dimensions addressing
    capability. The linear addressing nodes contains the information of all DMA channel features except the 2
    dimension addressing features and the 2 dimensions addressing nodes contain the information of all available
    features.

        (+) Use HAL_DMAEx_List_BuildNode() to build the DMA linked-list node according to the specified parameters.
            Build operation allow to convert the specified parameter in values known by the DMA channel and place them
            in memory.
            Placing DMA linked-list in SRAM must be done in accordance to product specification to ensure that the
            link access port can access to the specified SRAM.
            (++) The DMA linked-list node parameter address should be 32bit aligned and should not exceed the 64 KByte
            addressable space.

        (+) Use HAL_DMAEx_List_GetNodeConfig() to get the specified configuration parameter on building node.
            This API can be used when need to change few parameter to build new node.

  *** Inserting nodes to linked-list queue ***
  [..]
    In order to build a sequence of DMA transaction with different configuration, we need to insert built node at
    linked-list queue (node present an elementary DMA transaction) in linked-list queue on any position to have the
    full flexibility of ordering nodes or extend the sequence of queue transactions.

        (+) Use HAL_DMAEx_List_InsertNode() to insert new built node in any queue position of linked-list queue
            according to selecting previous node. When calling this API with previous node parameter is NULL, the
            inserted node will be placed at the head of the linked-list queue.
            (++) This API must be used after HAL_DMAEx_List_BuildNode() otherwise an error will be returned.
            (++) This API must be called for static queues format.
            (++) This API shall be avoided when adding new node at the head or the tail of queue (overhead of
                 footprint and performance : use HAL_DMAEx_List_InsertNode_Head() or HAL_DMAEx_List_InsertNode_Tail()
                 instead).

        (+) Use HAL_DMAEx_List_InsertNode_Head() to insert new built node at the head of linked-list queue. The head
            node will not be overwritten but will be the second queue node.
            (++) This API must be used after HAL_DMAEx_List_BuildNode() otherwise an error will be returned.
            (++) This API must be called for static queues format.

        (+) Use HAL_DMAEx_List_InsertNode_Tail() to insert new built node at the tail of linked-list queue. The tail
            node will not be overwritten but will be the penultimate queue node.
            (++) This API must be used after HAL_DMAEx_List_BuildNode() otherwise an error will be returned.
            (++) This API must be called for static queues format.

  *** Removing nodes from linked-list queue ***
  [..]
    There is some cases when removing a node from linked-list queue is needed (need to remove an elementary DMA
    transaction). Removing node allows to unlink a node from DMA linked-list queue (NOT DELETED), so the removed node
    can be reused for another queue or to be added to the same queue without need to rebuild it in next step.

        (+) Use HAL_DMAEx_List_RemoveNode() to remove any yet built and inserted node from linked-list queue according
            to selected node.
            (++) This API must be called for static queues format.
            (++) This API shall be avoided when removing the head or the tail of linked-list queue (overhead of
                 footprint and performance : use HAL_DMAEx_List_RemoveNode_Head() or HAL_DMAEx_List_RemoveNode_Tail()
                 instead).

        (+) Use HAL_DMAEx_List_RemoveNode_Head() to remove the head node from linked-list queue.
            (++) This API must be called for static queues format.

        (+) Use HAL_DMAEx_List_RemoveNode_Tail() to remove the tail node from linked-list queue.
            (++) This API must be called for static queues format.

  *** Replacing nodes on linked-list queue ***
  [..]
    There is some cases when replacing a node from linked-list queue is needed (need to replace an elementary DMA
    transfer, by another one that have not the same configuration). Replacing node allows to unlink the node to be
    replaced from DMA linked-list queue (NOT DELETED) and link instead a new node. So the replaced node can be reused
    for another queue or to be added to the same queue without need to rebuild it in next step and the new node cannot
    be reused except when remove it or replaced in next step.

        (+) Use HAL_DMAEx_List_ReplaceNode() to replace any yet built and inserted node on linked-list queue according
            to selected node.
            (++) This API must be called for static queues format.
            (++) This API shall be avoided when replacing the head or the tail linked-list queue (overhead of
                 footprint and performance : use HAL_DMAEx_List_ReplaceNode_Head() or
                 HAL_DMAEx_List_ReplaceNode_Tail() instead).

        (+) Use HAL_DMAEx_List_ReplaceNode_Head() to replace the head node of linked-list queue.
            (++) This API must be called for static queues format.

        (+) Use HAL_DMAEx_List_ReplaceNode_Tail() to replace the tail node from linked-list queue.
            (++) This API must be called for static queues format.

  *** Reset linked-list queue ***
  [..]
    After finishing using a linked-list queue, it can be reset and cleared and it's content nodes will be
    unlinked (NOT DELETED) and reused on another queue.

        (+) Use HAL_DMAEx_List_ResetQ() to reset a linked-list queue and unlink all it's content nodes.
            (++) This API must be called for ready state queues.
            (++) This API must be called for static queues format.

  *** Inserting linked-list queue ***
  [..]
    To ensure the flexibility of building linked-list queue by their targeted functionalities (Example: 3 nodes for
    action 1 and 5 nodes for action 2), it is possible to build a queue for action 1 that contains action 1 nodes and
    a queue for action 2 that contains action 2 nodes then concatenating the 2 queues. So, there are some cases where
    the management of linked-list at queue granularity is needed.

        (+) Use HAL_DMAEx_List_InsertQ() to insert source linked-list queue to a destination linked-list queue
            according to selecting previous node.
            (++) This API must be called for static queues format.
            (++) This API shall be avoided when inserting source linked-list queue at the head or the tail of
                 destination queue (overhead of footprint and performance : use HAL_DMAEx_List_InsertQ_Head() or
                 HAL_DMAEx_List_InsertQ_Tail() instead).

        (+) Use HAL_DMAEx_List_InsertQ_Head() to insert a source linked-list queue at the head of linked-list
            destination queue.
            (++) This API must be called for static queues format.

        (+) Use HAL_DMAEx_List_InsertQ_Tail() to insert a source linked-list queue at the tail of linked-list
            destination queue.
            (++) This API must be called for static queues format.

  *** Circularizing linked-list queue ***
  [..]
    In order to perform tasks in infinite loop with DMA channel, it is possible to circularize the linked-list queues.
    Circularizing queue allows to link last linked-list queue node to any previous node of the same queue (This node
    is named first circular queue). When the first circular node is the head node, all linked-list queue nodes will be
    executed in infinite loop. When the first circular node is not the head nodes, all precedent nodes are executed
    once and all remaining nodes are executed in an infinite loop.

        (+) Use HAL_DMAEx_List_SetCircularModeConfig() to circularize the linked-list queue according to first
            circular node selected.
            (++) This API must be called for static queues format.
            (++) This API shall be avoided when first circular node is the head linked-list queue node (overhead of
                 footprint and performance : use HAL_DMAEx_List_SetCircularMode() instead).

        (+) Use HAL_DMAEx_List_SetCircularMode() to circularize the linked-list queue with linking last queue node
            with first queue node.
            (++) This API must be called for static queues format.

        (+) Use HAL_DMAEx_List_ClearCircularMode() to clear any linked-list queue circular configuration.
            (++) This API must be called for static queues format.


  *** Converting linked-list queue ***
  [..]
    To have the best DMA channel linked-list queue execution, it is recommended to convert yet build linked-list queue
    to dynamic format (Static is the default format). When linked-list queue becomes dynamic, all queue nodes are
    optimized and only changed parameters will be updated between nodes. So, the DMA will fetch only changes
    parameters instead of the whole node.

        (+) Use HAL_DMAEx_List_ConvertQToDynamic() to convert a linked-list queue to dynamic format.
            (++) This API must be called for ready state queues.
            (++) This API must be called for static queues format.
            (++) This API must be called as the last API before starting the DMA channel in linked-list mode.

        (+) Use HAL_DMAEx_List_ConvertQToStatic() to convert a linked-list queue to static format.
            (++) This API must be called for ready state queues.
            (++) This API must be called for dynamic queues format.
            (++) This API must be called as the first API after the full execution of linked-list queue when the
                 execution mode is linear (not circular) if it is dynamic and a linked-list queue management is
                 needed.
            (++) This API must be called as the first API after the aborting the execution of the current linked-list
                 queue when the execution mode is linear (not circular) if it is dynamic and a linked-list queue
                 management is needed.

  [..]
    When converting a circular queue to dynamic format and when the first circular node is the last queue node, it is
    recommended to duplicate the last circular node in order to ensure the full optimization when calling
    HAL_DMAEx_List_ConvertQToDynamic() API. In this case, updated information are only addresses which allow to reduce
    4 words of update for linear nodes per node execution and 6 words update for 2 dimensions addressing nodes per
    node execution.


  *** Linking linked-list queue to DMA channel ***
  [..]
    In order to have the possibility of the creation of an infinity queues (limited by available memory size), the
    building of linked-list queue is fully independent from DMA channels. It is possible to build all needed queues if
    their size is less then available memory at startup time, then linking each time when needed a linked-list queue
    to an idle DMA channel.

        (+) Use HAL_DMAEx_List_LinkQ() to link a ready linked-list queue to ready DMA channel.
            (++) This API supports the two format of linked-list (Static and dynamic).
            (++) This API must be called for ready state queues and DMA channels.

        (+) Use HAL_DMAEx_List_ConvertQToStatic() to unlink a ready linked-list queue to ready DMA channel.
            (++) This API supports the two format of linked-list (Static and dynamic).
            (++) This API must be called for ready state queues and DMA channels.

  *** User sequence ***
  [..]
    To use cleanly the DMA linked-list library, ensure to apply the following call sequences :

        (+) Linear transfer :
            Linked-list queue building
            (++) HAL_DMAEx_List_BuildNode()
            (++) HAL_DMAEx_List_InsertNode_Tail()
                            .
                            .
                            .
            (++) HAL_DMAEx_List_BuildNode()
            (++) HAL_DMAEx_List_InsertNode_Tail()
            (++) HAL_DMAEx_List_ConvertQToDynamic()
            Linked-list queue execution
            (++) HAL_DMAEx_List_Init()
            (++) HAL_DMAEx_List_LinkQ()
            (++) HAL_DMAEx_List_Start() / HAL_DMAEx_List_Start_IT()
            (++) HAL_DMAEx_List_UnLinkQ()
            (++) HAL_DMAEx_List_DeInit()

        (+) Circular transfer :
            Linked-list queue building
            (++) HAL_DMAEx_List_BuildNode()
            (++) HAL_DMAEx_List_InsertNode_Tail()
                            .
                            .
                            .
            (++) HAL_DMAEx_List_BuildNode()
            (++) HAL_DMAEx_List_InsertNode_Tail()
            (++) HAL_DMAEx_List_SetCircularModeConfig() / HAL_DMAEx_List_SetCircularMode()
            (++) HAL_DMAEx_List_ConvertQToDynamic()
            Linked-list queue execution
            (++) HAL_DMAEx_List_Init()
            (++) HAL_DMAEx_List_LinkQ()
            (++) HAL_DMAEx_List_Start() / HAL_DMAEx_List_Start_IT()
            (++) HAL_DMA_Abort() / HAL_DMA_Abort_IT()
            (++) HAL_DMAEx_List_UnLinkQ()
            (++) HAL_DMAEx_List_DeInit()


  *** Data Handling ***
  =====================
  [..]
    In order to avoid some CPU data processing in several cases, the DMA channel provides some features related to
    FIFO capabilities titled data handling.
              (++) Padding pattern
                   Padding selected pattern (zero padding or sign extension) when the source data width is smaller
                   than the destination data width at single level.
                   Zero padding       (Source : 0xABAB ------&gt; Destination : 0xABAB0000)
                   Sign bit extension (Source : 0x0ABA ------&gt; Destination : 0x00000ABA)
                                      (Source : 0xFABA ------&gt; Destination : 0xFFFFFABA)
              (++) Truncation :
                   Truncate section from the source data single when the source data width is bigger than the
                   destination data width.
                   Left truncation  (Source : 0xABABCDCD ------&gt; Destination : 0xCDCD)
                   Right truncation (Source : 0xABABCDCD ------&gt; Destination : 0xABAB)
              (++) Pack/Unpack :
                   Pack a set of data when source data width is smaller than the destination data width.
                   Unpack a set of data when source data width is bigger than the destination data width.
                   Pack   (Source : 0xAB, 0xCD ------&gt; Destination : 0xABCD)
                   UnPack (Source : 0xABCD     ------&gt; Destination : 0xAB, 0xCD)
              (++) Exchange :
                   Exchange data at byte and half-word on the destination and at byte level on the source.
                   Considering source and destination are both word type. Exchange operation can be as follows.
                   In examples below, one exchange setting is enabled at a time.
                   Source byte exchange only (Source : 0xAB12CD34 ------&gt; Destination : 0xABCD1234)
                   Destination byte exchange only (Source : 0xAB12CD34 ------&gt; Destination : 0x12AB34CD)
                   Destination half-word exchange only (Source : 0xAB12CD34 ------&gt; Destination : 0xCD34AB12)

        (+) Use HAL_DMAEx_ConfigDataHandling() to configure data handling features. Previous elementary explained
            can be combined according to application needs.
            (++) This API is complementary of normal transfers.
            (++) This API must not be called for linked-list transfers as data handling information are configured at
                 node level.

  *** User sequence ***
  [..]
    To configure cleanly the DMA channel data handling, ensure to apply the following call sequence :

        (+) Linear transfer :
            (++) HAL_DMA_Init()
            (++) HAL_DMAEx_ConfigDataHandling()
            (++) HAL_DMA_Start()

  *** Repeated Block ***
  ======================
  [..]
    When available, this feature is used when the data size is higher then 65535 bytes (Maximum block size) or for
    scattering / gathering data.
              (++) Gather data
                   Source            Destination
                   0xAA              0xAA
                   0xBB              0xAA
                   0xAA      ==&gt;     0xAA
                   0xCC
                   0xAA
              (++) Scatter data
                   Source            Destination
                   0xAA              0xAA
                   0xAA              0xBB
                   0xAA      ==&gt;     0xAA
                                     0xBB
                                     0xAA

        (+) Use HAL_DMAEx_ConfigRepeatBlock() to configure data repeated block feature. Jump addresses and
            incrementing or decrementing on source and destination can be combined to have the need application
            behavior.
            (++) This API is complementary of normal transfers.
            (++) This API must not be called for linked-list transfers as repeated block information are configured at
                 node level.
            (++) This API must be called only for DMA channel that supports repeated block feature.

  *** User sequence ***
  [..]
    To configure cleanly the DMA channel repeated block, ensure to apply the following call sequence :

        (+) Linear transfer :
            (++) HAL_DMA_Init()
            (++) HAL_DMAEx_ConfigRepeatBlock()
            (++) HAL_DMA_Start()

  *** Trigger Configuration ***
  =============================
  [..]
    When application needs that DMA transfers are conditioned by internal or external events, the trigger feature can
    do that. Trigger signals are a set of device signal that are linked to DMA trigger inputs that allows to start the
    DMA transfers.
    To setup a trigger transfers, three DMA channel parameters are needed:

        (+) Trigger mode
            This parameter specifies the trig level.
             (++) Block level
             (++) Repeated block level
             (++) Node level
             (++) Single / Burst level

        (+) Trigger polarity
            This parameter specifies the DMA trigger sensitivity (Rising or falling).

        (+) Trigger selection
            This parameter specifies the DMA trigger hardware signal.

        (+) Use HAL_DMAEx_ConfigTrigger() to configure trigger feature.
            (++) This API is complementary to normal transfers APIs.
            (++) This API must not be called for linked-list transfers as trigger information are configured at
                 node level.

  *** User sequence ***
  [..]
    To configure cleanly the DMA channel trigger, ensure to apply the following call sequence :
        (+) Linear transfer :
            (++) HAL_DMA_Init()
            (++) HAL_DMAEx_ConfigTrigger()
            (++) HAL_DMA_Start()

  *** Suspend and resume operation ***
  ====================================
  [..]
    There are several cases when needs to suspend a DMA current transfer (Example: liberate bandwidth for more
    priority DMA channel transfer). Suspending DMA channel (same as abort) is available in polling (blocking mode) and
    interrupt (non-blocking mode) modes. When suspended, a DMA channel can be instantly resumed.

        (+) Use HAL_DMAEx_Suspend() to suspend an ongoing DMA channel transfer in polling mode (Blocking mode).

        (+) Use HAL_DMAEx_Suspend_IT() to suspend an ongoing DMA channel transfer in interrupt mode (Non-blocking
            mode).

        (+) Use HAL_DMAEx_Resume() to resume a suspended DMA channel transfer execution.

  *** FIFO status ***
  ===================
  [..]
    In several cases, the information of FIFO level is useful to inform at application level how to process remaining
    data. When not empty, the DMA channel FIFO cannot be flashed only by reset.

        (+) Use HAL_DMAEx_GetFifoLevel() to get the DMA channel FIFO level (available beats in FIFO).
</pre> 
<p class="definition">Definition in file <a class="el" href="stm32h5xx__hal__dma__ex_8c_source.html">stm32h5xx_hal_dma_ex.c</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_74b6a3b63f61c160c0f14b7a283a4c9b.html">Firmware</a></li><li class="navelem"><a class="el" href="dir_f86e3d2d729eeb8991b01a437a807aa5.html">Drivers</a></li><li class="navelem"><a class="el" href="dir_0ffb97dd1c0741626f6b666905986dda.html">STM32H5xx_HAL_Driver</a></li><li class="navelem"><a class="el" href="dir_06f666ee06dcaf5c61cd73099dbbad52.html">Src</a></li><li class="navelem"><a class="el" href="stm32h5xx__hal__dma__ex_8c.html">stm32h5xx_hal_dma_ex.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
